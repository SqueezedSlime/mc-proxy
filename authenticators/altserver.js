const https = require('https');
const tls = require('tls');
const { generateClientToken } = require('./mojang');
const { MCAuthenticator } = require('./base');


//The altening uses hacks with HTTPS requests
//So it deserves a makeRequest function on its own...
function makeAltServerRequest({ getEndpoints, certs, hostnames }, host, endpoint, body) {
    //needEndpoints is true if it uses the mojang endpoints (masked on the altening servers) with self signed certs.
    //false if it just uses an normal https endpoint (such as https://api.thealtening.com)
    //It can get the ips by https://api.thealtening.com/status
    var needEndpoints = ['sessionserver.mojang.com', 'authserver.mojang.com'].includes(host);
    //a promise that resolves with the endpoints (if needed), otherwise empty object
    var onEndpoints = Promise.resolve(needEndpoints ? getEndpoints() : {});

    //headers for the post reqest
    var postHeaders = {};
    var data = null;
    if(body) {
        data = Buffer.from(JSON.stringify(body), 'utf-8');
        postHeaders = {
            'Content-Type': 'application/json',
            'Content-Length': data.length
        }
    }


    return onEndpoints.then(endpoints => new Promise((resolve, reject) => {
        if(endpoints instanceof Error) {
            reject(endpoints);
            return;
        }

        //if needendpoints=true:
        //We must make sure that the request EXACTLY match as the one that will be generated by the vanilla minecraft launcher
        //The only variable that changes, is the destination IP for IP packets, the rest remain the same (HOST, SNI, headers, path and payload)
        //Notice: there is not only a HTTP HOST header, but SSL also has a SNI (server name) field before the encryption. 
        //        So the server knows which certificate it must use.
        //
        //
        //The altening authenticator just redirects any IP packet originally destinated to authserver.mojang.com/sessionserver.mojang.com to the altening servers
        //To ensure that you don't get SSL verfication errors, the altening authenticator installs their certs on your windows system.
        
        var req = https.request({
            method: "POST",
            //a mapping to get the altening replacement IP for the authentication servers of Mojang.
            host: ({'sessionserver.mojang.com': endpoints.session, 'authserver.mojang.com': endpoints.authentication})[host] || host,
            port: 443,
            path: endpoint,
            servername: host, //servername == SNI for ssl
            rejectUnauthorized: false,
            headers: {
                'Host': host,
                ...postHeaders
            }
        }, res => {
            var data = [];
            var len = 0;
            res.on('error', ex => reject(ex));
            res.on('data', d => {
                len += d.length;
                //we limit the amount of data
                if(len > 65535) {
                    reject(new Error("Too much data"));
                    try{res.destroy(new Error("Too much data"));}catch(_){}
                    return;
                }
                data.push(d);
            });
            res.on('end', () => {
                try {
                    if(res.statusCode === 204 || data.length < 1) {
                        if(len > 0) reject(new RangeError("Data on no content"));
                        else resolve(null);
                        return;
                    }
                    if(res.statusCode !== 200) {
                        var message = "Unknown error";
                        try {
                            var json = JSON.parse(Buffer.concat(data).toString('utf-8'));
                            if(json && typeof json == 'object') message = json.errormessage || json.errorMessage || json.message || json.description || json.error || message;
                        } catch(_) {}
                        var err = new Error("Request failed: " + res.statusCode + " " + message);
                        err.response = res;
                        reject(err);
                        return;
                    }
                    resolve(JSON.parse(Buffer.concat(data).toString('utf-8')));
                } catch(ex) {
                    reject(ex);
                }
            });
        }).on('socket', socket => socket.prependListener('secure', () => {
            //we check the cert by ourself.
            try {
                //see https://github.com/nodejs/node/blob/master/lib/_tls_wrap.js
                //if isSessionReused() == true, checkServerIdentity is not called. So we do not call it either.
                if(socket.isSessionReused()) return;
                //check cert by ourself
                var cert = socket.getPeerCertificate(true);
                if(!cert || !cert.fingerprint256) throw new Error("No cert");
                if(!needEndpoints) { //useless if needEndpoints == true. Should always return an error then.
                    try {
                        if(tls.checkServerIdentity(host, cert) == null) return;
                    } catch(ex){
                        socket.destroy(ex);
                        return;
                    }
                }
                if(!['sessionserver.mojang.com', 'authserver.mojang.com', ...hostnames].includes(host)) throw new Error("Invalid hostname")
                while(cert.issuerCertificate && cert.issuerCertificate !== cert) cert = cert.issuerCertificate;
                if(!certs.includes(String(cert.fingerprint256).toUpperCase())) throw new Error("Invalid cert fingerprint");
            } catch(ex) {
                socket.destroy(ex);
                return;
            }
        })).on('error', ex => reject(ex));
        if(data) req.write(data);
        req.end();
    }));
}

class AltServerAuthenticator extends MCAuthenticator {
    /**
     * Create a new AltServerAuthenticator, for (most) websites where you can redeem alt tokens to get accounts, use login() to redeem the alt token
     * @param {{ getEndpoints: async () => {[host: string]: string}, certs: string[], hostnames: []}} options Config that describes
     * @param {string} altToken An alt token
     */
    constructor(options, altToken) {
        super();
        this.serverOptions = options;
        this.altToken = String(altToken);
    } 

    //You may want to look at this: https://wiki.vg/Authentication
    //The endpoints are the same

    /**
     * Redeem the ALT token, that is used to construct this class
     * @returns {Promise<AlteningAuthenticator>} Promise that resolves with this class or rejects with an error.
     */
    login() {
        return this.addWaitlist(() => generateClientToken()
            .then(clientToken => this.clientToken = clientToken)
            .then(() => makeAltServerRequest(this.serverOptions, 'authserver.mojang.com', '/authenticate', {
                agent: {
                    name: "minecraft",
                    version: 1
                },
                username: this.altToken,
                password: 'anything', //password does not matter, we also use the same value that their /info endpoint (not used here) returns in the password field.
                clientToken: this.clientToken,
                requestUser: true
            }))
            .then(result => {
                if(!result || typeof result !== 'object' || !result.accessToken || typeof result.accessToken !== 'string' || !result.selectedProfile || typeof result.selectedProfile !== 'object' || !result.selectedProfile.name || typeof result.selectedProfile.name !== 'string' || !result.selectedProfile.id || typeof result.selectedProfile.id !== 'string') 
                    throw new TypeError("Invalid JSON data");
                Object.assign(this, {
                    name: result.selectedProfile.name,
                    uuid: result.selectedProfile.id,
                    accessToken: result.accessToken,
                    created: new Date(),
                    refreshed: new Date()
                });
            })
        );
    }

    /**
     * Refresh the access token (and expands lifetime of BOTH the alt token and alt session)
     * @returns {Promise} promise that resolves with null or rejects with an Error
     */
    refresh() {
        var accessToken, clientToken, uuid, name;
        return this.addWaitlist(() => Promise.resolve()
            .then(() => {
                if(!this.accessToken) throw new Error("You must first redeem the code");
                accessToken = this.accessToken;
                clientToken = this.clientToken;
                uuid = this.uuid;
                name = this.name;
            })
            .then(() => makeAltServerRequest(this.serverOptions, 'authserver.mojang.com', '/refresh', {
                accessToken,
                clientToken,
                selectedProfile: {
                    id: uuid,
                    name
                },
                requestUser: true
            })).then(result => {
                if(!result || typeof result !== 'object' || !result.accessToken || typeof result.accessToken !== 'string') 
                    throw new TypeError("Invalid JSON data");
                return Object.assign(this, {
                    accessToken: result.accessToken,
                    created: new Date(),
                    refreshed: new Date()
                });
            })
        );
    }

    /**
     * Validate the current session. If not valid you can try to redeem the alt token again
     * @returns {Promise} resolves with true or false (never errors)
     */
    validate() {
        return this.addWaitlist(() => Promise.resolve()
            .then(() => {
                if(!this.accessToken) throw new Error("You must first redeem the code");
            })
            .then(() => makeAltServerRequest(this.serverOptions, 'authserver.mojang.com', '/validate', {
                accessToken: this.accessToken,
                clientToken: this.clientToken
            })).then(res => {
                if(res !== null) throw new Error("Expected 204 if valid");
                return true;
            }, () => false)
        );
    }

    /**
     * Invalidates the current (fake altening) session token, you can still try to redeem it again with redeem()
     * So this is maybe useless, because you are not invalidating the alt token (which is, so far I found, not possible).
     * @returns {Promise}
     */
    invalidate() {
        this.keepAlive(false);
        return this.addWaitlist(() => Promise.resolve()
            .then(() => {
                if(!this.accessToken) throw new Error("You must first redeem the code");
            })
            .then(() => makeAltServerRequest(this.serverOptions, 'authserver.mojang.com', '/invalidate', {
                accessToken: this.accessToken,
                clientToken: this.clientToken
            }))
            .then(res => {
                Object.assign(this, {
                    accessToken: null,
                    clientToken: null
                });
                if(res !== null) throw new Error("Expected 204 if valid");
                return true;
            })
        );  
    }

    signServerHash(serverHash) {
        return this.addWaitlist(() => Promise.resolve()
            .then(() => {
                if(!this.accessToken) throw new Error("You must first redeem the code");
            }).then(() => makeAltServerRequest(this.serverOptions, 'sessionserver.mojang.com', '/session/minecraft/join', {
                accessToken: this.accessToken,
                selectedProfile: this.uuid,
                serverId: serverHash
            }))
            .then(res => {
                if(res != null) throw new Error("Join server expects 204");
                return true;
            })
        );
        
    }


}

module.exports = { makeAltServerRequest, AltServerAuthenticator };
